<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Daniel Pedraza</title>
        <meta
            name="description"
            content="Deployment strategist and systems engineer building the future of autonomous systems."
        />

        <!-- External Stylesheets -->
        <link rel="stylesheet" href="base-styles.css" />
        <link rel="stylesheet" href="index.css" />
    </head>
    <body>
        <!-- Interactive Graph Background -->
        <canvas
            id="graph-canvas"
            style="
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: -1;
            "
        ></canvas>

        <!-- Paint Splatter Layer (on top) -->
        <canvas
            id="splatter-canvas"
            style="
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 2;
                pointer-events: none;
            "
        ></canvas>

        <!-- Main Content -->
        <div class="container">
            <div class="profile">
                <img
                    src="profile.jpg"
                    alt="Daniel Pedraza"
                    class="profile-img"
                />
                <h1>Daniel Pedraza</h1>
                <p class="tagline">Curious. Relentless. Engineer.</p>

                <!-- Social Links -->
                <div class="social-links">
                    <!-- LinkedIn -->
                    <a
                        href="https://linkedin.com/in/sumdp"
                        target="_blank"
                        rel="noopener noreferrer"
                        aria-label="LinkedIn"
                    >
                        <svg fill="currentColor" viewBox="0 0 24 24">
                            <path
                                d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
                            ></path>
                        </svg>
                    </a>

                    <!-- GitHub -->
                    <a
                        href="https://github.com/sumdp"
                        target="_blank"
                        rel="noopener noreferrer"
                        aria-label="GitHub"
                    >
                        <svg fill="currentColor" viewBox="0 0 24 24">
                            <path
                                d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
                            ></path>
                        </svg>
                    </a>

                    <!-- Email -->
                    <a href="mailto:daniel.pedraza@me.com" aria-label="Email">
                        <svg
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M3 8l7.89 4.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
                            ></path>
                        </svg>
                    </a>
                </div>

                <!-- Navigation -->
                <div class="nav-links">
                    <a href="index.html">Home</a>
                    <a href="about.html">About</a>
                    <a href="#blog">Blog</a>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer>Daniel Pedraza Â© 2025</footer>

        <script>
            const canvas = document.getElementById("graph-canvas");
            const ctx = canvas.getContext("2d");

            const splatterCanvas = document.getElementById("splatter-canvas");
            const splatterCtx = splatterCanvas.getContext("2d");

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                splatterCanvas.width = window.innerWidth;
                splatterCanvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener("resize", resizeCanvas);

            class DataParticle {
                constructor(startNode, endNode, color) {
                    this.start = startNode;
                    this.end = endNode;
                    this.progress = 0;
                    this.speed = 0.01 + Math.random() * 0.02;
                    this.color = color;
                    this.size = 2 + Math.random() * 2;
                }

                update() {
                    this.progress += this.speed;
                    return this.progress < 1;
                }

                draw() {
                    const x =
                        this.start.x +
                        (this.end.x - this.start.x) * this.progress;
                    const y =
                        this.start.y +
                        (this.end.y - this.start.y) * this.progress;

                    ctx.beginPath();
                    ctx.arc(x, y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();

                    ctx.beginPath();
                    const gradient = ctx.createRadialGradient(
                        x,
                        y,
                        0,
                        x,
                        y,
                        this.size * 3,
                    );
                    gradient.addColorStop(0, this.color.replace("1)", "0.6)"));
                    gradient.addColorStop(1, this.color.replace("1)", "0)"));
                    ctx.fillStyle = gradient;
                    ctx.arc(x, y, this.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class Node {
                constructor(x, y, type = "normal") {
                    this.x = x;
                    this.y = y;
                    this.prevX = x;
                    this.prevY = y;
                    this.type = type;

                    const speedMultiplier =
                        type === "hub"
                            ? 0.3
                            : type === "fast"
                              ? 1.5
                              : type === "orbital"
                                ? 0.8
                                : 1;
                    this.vx = (Math.random() - 0.5) * 0.7 * speedMultiplier;
                    this.vy = (Math.random() - 0.5) * 0.7 * speedMultiplier;
                    this.ax = 0;
                    this.ay = 0;

                    this.radius =
                        type === "hub"
                            ? 6
                            : type === "small"
                              ? 1.5
                              : type === "mega"
                                ? 8
                                : 3;

                    this.pulsePhase = Math.random() * Math.PI * 2;
                    this.pulseSpeed = 0.015 + Math.random() * 0.04;
                    this.rotationAngle = Math.random() * Math.PI * 2;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.02;

                    this.opacity =
                        type === "hub" || type === "mega" ? 0.7 : 0.4;

                    this.trail = [];
                    this.maxTrailLength = type === "fast" ? 8 : 0;

                    this.energy = Math.random();
                    this.connections = [];
                }

                update() {
                    this.prevX = this.x;
                    this.prevY = this.y;

                    this.vx += this.ax;
                    this.vy += this.ay;

                    this.vx *= 0.99;
                    this.vy *= 0.99;

                    this.x += this.vx;
                    this.y += this.vy;

                    this.ax = 0;
                    this.ay = 0;

                    if (this.x < 0 || this.x > canvas.width) {
                        this.vx *= -0.95;
                        this.vx += (Math.random() - 0.5) * 0.15;
                    }
                    if (this.y < 0 || this.y > canvas.height) {
                        this.vy *= -0.95;
                        this.vy += (Math.random() - 0.5) * 0.15;
                    }

                    this.x = Math.max(0, Math.min(canvas.width, this.x));
                    this.y = Math.max(0, Math.min(canvas.height, this.y));

                    this.pulsePhase += this.pulseSpeed;
                    this.rotationAngle += this.rotationSpeed;
                    this.energy = (Math.sin(this.pulsePhase * 0.5) + 1) / 2;

                    if (this.maxTrailLength > 0) {
                        this.trail.push({ x: this.x, y: this.y });
                        if (this.trail.length > this.maxTrailLength) {
                            this.trail.shift();
                        }
                    }
                }

                applyForce(fx, fy) {
                    this.ax += fx;
                    this.ay += fy;
                }

                draw() {
                    const pulse = Math.sin(this.pulsePhase) * 0.4 + 1;
                    const currentRadius = this.radius * pulse;
                    const speed = Math.sqrt(
                        this.vx * this.vx + this.vy * this.vy,
                    );

                    // GREY trails
                    if (this.trail.length > 1) {
                        for (let i = 0; i < this.trail.length - 1; i++) {
                            const alpha = (i / this.trail.length) * 0.3;
                            ctx.beginPath();
                            ctx.strokeStyle = `rgba(120, 120, 120, ${alpha})`;
                            ctx.lineWidth = 2;
                            ctx.moveTo(this.trail[i].x, this.trail[i].y);
                            ctx.lineTo(
                                this.trail[i + 1].x,
                                this.trail[i + 1].y,
                            );
                            ctx.stroke();
                        }
                    }

                    // GREY glowing layers
                    if (this.type === "hub" || this.type === "mega") {
                        for (let i = 3; i > 0; i--) {
                            ctx.beginPath();
                            const gradient = ctx.createRadialGradient(
                                this.x,
                                this.y,
                                0,
                                this.x,
                                this.y,
                                currentRadius * i * 1.5,
                            );
                            const color =
                                this.type === "mega"
                                    ? "130, 130, 130"
                                    : "110, 110, 110";
                            gradient.addColorStop(
                                0,
                                `rgba(${color}, ${(this.opacity * 0.2 * pulse) / i})`,
                            );
                            gradient.addColorStop(1, `rgba(${color}, 0)`);
                            ctx.fillStyle = gradient;
                            ctx.arc(
                                this.x,
                                this.y,
                                currentRadius * i * 1.5,
                                0,
                                Math.PI * 2,
                            );
                            ctx.fill();
                        }
                    }

                    // GREY orbiting particles
                    if (this.type === "mega") {
                        for (let i = 0; i < 3; i++) {
                            const angle =
                                this.rotationAngle + (i * Math.PI * 2) / 3;
                            const orbitRadius = currentRadius * 2.5;
                            const ox = this.x + Math.cos(angle) * orbitRadius;
                            const oy = this.y + Math.sin(angle) * orbitRadius;

                            ctx.beginPath();
                            ctx.arc(ox, oy, 1.5, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(120, 120, 120, 0.8)`;
                            ctx.fill();
                        }
                    }

                    // GREY energy ring
                    ctx.beginPath();
                    ctx.arc(
                        this.x,
                        this.y,
                        currentRadius * 1.3,
                        0,
                        Math.PI * 2,
                    );
                    ctx.strokeStyle = `rgba(120, 120, 120, ${this.energy * 0.3})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();

                    // GREY main node
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);

                    if (this.type === "mega") {
                        ctx.fillStyle = `rgba(130, 130, 130, ${this.opacity})`;
                    } else if (this.type === "hub") {
                        ctx.fillStyle = `rgba(110, 110, 110, ${this.opacity})`;
                    } else {
                        const speedColor = Math.min(speed * 50, 50);
                        ctx.fillStyle = `rgba(${100 + speedColor}, ${100 + speedColor}, ${100 + speedColor}, ${this.opacity})`;
                    }
                    ctx.fill();

                    // Light grey highlight
                    ctx.beginPath();
                    ctx.arc(
                        this.x - currentRadius * 0.3,
                        this.y - currentRadius * 0.3,
                        currentRadius * 0.4,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fillStyle = `rgba(180, 180, 180, ${this.opacity * 0.6})`;
                    ctx.fill();
                }
            }

            const nodes = [];
            const nodeCount = Math.floor(
                (canvas.width * canvas.height) / 10000,
            );

            for (let i = 0; i < nodeCount; i++) {
                const rand = Math.random();
                const type =
                    rand < 0.05
                        ? "mega"
                        : rand < 0.15
                          ? "hub"
                          : rand < 0.25
                            ? "small"
                            : rand < 0.35
                              ? "fast"
                              : rand < 0.45
                                ? "orbital"
                                : "normal";

                nodes.push(
                    new Node(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        type,
                    ),
                );
            }

            const dataParticles = [];
            let particleSpawnTimer = 0;

            // Realistic Paint Splatter System
            class PaintSplatter {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.size = 30 + Math.random() * 50;
                    this.colors = [
                        "#182FFF",
                        "#0106AD",
                        "#4EA9FE",
                        "#FF0004",
                        "#BA2803",
                        "#FF8908",
                        "#E06A17",
                        "#FDD322",
                        "#F9F562",
                        "#3CE702",
                        "#85FF30",
                        "#C9FF10",
                        "#1A8A42",
                        "#276D01",
                        "#FE2DFF",
                        "#F6108F",
                        "#C022B2",
                    ];
                    this.color =
                        this.colors[
                            Math.floor(Math.random() * this.colors.length)
                        ];
                    this.opacity = 0;
                    this.targetOpacity = 0.7 + Math.random() * 0.2; // 70-90%
                    this.fadeSpeed = 0.015;
                    this.fadeIn = true;
                    this.lifespan = 600 + Math.random() * 400; // longer life
                    this.age = 0;

                    // Generate realistic splatter components
                    this.mainBlob = this.generateMainBlob();
                    this.droplets = this.generateDroplets();
                    this.streaks = this.generateStreaks();
                }

                generateMainBlob() {
                    // Create irregular blob shape
                    const points = [];
                    const numPoints = 12 + Math.floor(Math.random() * 8);

                    for (let i = 0; i < numPoints; i++) {
                        const angle = (Math.PI * 2 * i) / numPoints;
                        const radiusVar = 0.7 + Math.random() * 0.6; // More variation
                        const radius = this.size * radiusVar;
                        points.push({
                            x: Math.cos(angle) * radius,
                            y: Math.sin(angle) * radius,
                        });
                    }
                    return points;
                }

                generateDroplets() {
                    const droplets = [];
                    const numDroplets = 15 + Math.floor(Math.random() * 20);

                    for (let i = 0; i < numDroplets; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance =
                            this.size * (1.2 + Math.random() * 1.5);
                        const size =
                            Math.random() * Math.random() * this.size * 0.3; // Smaller droplets

                        droplets.push({
                            x: Math.cos(angle) * distance,
                            y: Math.sin(angle) * distance,
                            size: size,
                            points: this.generateSmallBlob(size),
                        });
                    }

                    return droplets;
                }

                generateSmallBlob(size) {
                    const points = [];
                    const numPoints = 5 + Math.floor(Math.random() * 4);

                    for (let i = 0; i < numPoints; i++) {
                        const angle = (Math.PI * 2 * i) / numPoints;
                        const radiusVar = 0.6 + Math.random() * 0.8;
                        points.push({
                            x: Math.cos(angle) * size * radiusVar,
                            y: Math.sin(angle) * size * radiusVar,
                        });
                    }
                    return points;
                }

                generateStreaks() {
                    const streaks = [];
                    const numStreaks = 8 + Math.floor(Math.random() * 12);

                    for (let i = 0; i < numStreaks; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const startDist =
                            this.size * (0.8 + Math.random() * 0.4);
                        const length = this.size * (0.3 + Math.random() * 1.2);
                        const width = 1 + Math.random() * 3;

                        streaks.push({
                            startX: Math.cos(angle) * startDist,
                            startY: Math.sin(angle) * startDist,
                            endX: Math.cos(angle) * (startDist + length),
                            endY: Math.sin(angle) * (startDist + length),
                            width: width,
                        });
                    }

                    return streaks;
                }

                update() {
                    this.age++;

                    if (this.fadeIn) {
                        this.opacity += this.fadeSpeed;
                        if (this.opacity >= this.targetOpacity) {
                            this.opacity = this.targetOpacity;
                            this.fadeIn = false;
                        }
                    } else if (this.age > this.lifespan) {
                        this.opacity -= this.fadeSpeed * 0.5;
                    }

                    return this.opacity > 0;
                }

                draw() {
                    splatterCtx.save();
                    splatterCtx.translate(this.x, this.y);

                    const hexToRgba = (hex, opacity) => {
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    };

                    // Draw streaks first (behind)
                    this.streaks.forEach((streak) => {
                        splatterCtx.beginPath();
                        splatterCtx.moveTo(streak.startX, streak.startY);
                        splatterCtx.lineTo(streak.endX, streak.endY);
                        splatterCtx.strokeStyle = hexToRgba(
                            this.color,
                            this.opacity * 0.6,
                        );
                        splatterCtx.lineWidth = streak.width;
                        splatterCtx.lineCap = "round";
                        splatterCtx.stroke();
                    });

                    // Draw main blob
                    splatterCtx.beginPath();
                    splatterCtx.moveTo(this.mainBlob[0].x, this.mainBlob[0].y);
                    for (let i = 1; i < this.mainBlob.length; i++) {
                        const current = this.mainBlob[i];
                        const next =
                            this.mainBlob[(i + 1) % this.mainBlob.length];
                        const xc = (current.x + next.x) / 2;
                        const yc = (current.y + next.y) / 2;
                        splatterCtx.quadraticCurveTo(
                            current.x,
                            current.y,
                            xc,
                            yc,
                        );
                    }
                    splatterCtx.closePath();
                    splatterCtx.fillStyle = hexToRgba(this.color, this.opacity);
                    splatterCtx.fill();

                    // Draw droplets
                    this.droplets.forEach((droplet) => {
                        if (droplet.points.length > 0) {
                            splatterCtx.save();
                            splatterCtx.translate(droplet.x, droplet.y);

                            splatterCtx.beginPath();
                            splatterCtx.moveTo(
                                droplet.points[0].x,
                                droplet.points[0].y,
                            );
                            for (let i = 1; i < droplet.points.length; i++) {
                                const current = droplet.points[i];
                                const next =
                                    droplet.points[
                                        (i + 1) % droplet.points.length
                                    ];
                                const xc = (current.x + next.x) / 2;
                                const yc = (current.y + next.y) / 2;
                                splatterCtx.quadraticCurveTo(
                                    current.x,
                                    current.y,
                                    xc,
                                    yc,
                                );
                            }
                            splatterCtx.closePath();
                            splatterCtx.fillStyle = hexToRgba(
                                this.color,
                                this.opacity * 0.85,
                            );
                            splatterCtx.fill();

                            splatterCtx.restore();
                        }
                    });

                    splatterCtx.restore();
                }
            }

            const paintSplatters = [];
            let hoverStartTime = null;
            let lastHoverX = null;
            let lastHoverY = null;
            const hoverThreshold = 2000; // 2 seconds of hovering

            let mouse = { x: null, y: null, radius: 250, strength: 0.05 };

            document.addEventListener("mousemove", (e) => {
                const newX = e.clientX;
                const newY = e.clientY;

                // Check if mouse has moved significantly
                if (lastHoverX !== null && lastHoverY !== null) {
                    const distance = Math.sqrt(
                        Math.pow(newX - lastHoverX, 2) +
                            Math.pow(newY - lastHoverY, 2),
                    );

                    // If moved more than 20 pixels, reset hover timer
                    if (distance > 20) {
                        hoverStartTime = Date.now();
                        lastHoverX = newX;
                        lastHoverY = newY;
                    }
                } else {
                    hoverStartTime = Date.now();
                    lastHoverX = newX;
                    lastHoverY = newY;
                }

                mouse.x = newX;
                mouse.y = newY;

                // Check if hovering for too long
                if (
                    hoverStartTime &&
                    Date.now() - hoverStartTime > hoverThreshold
                ) {
                    paintSplatters.push(new PaintSplatter(mouse.x, mouse.y));
                    hoverStartTime = Date.now(); // Reset to prevent multiple splatters
                }
            });

            document.addEventListener("mouseleave", () => {
                mouse.x = null;
                mouse.y = null;
                hoverStartTime = null;
                lastHoverX = null;
                lastHoverY = null;
            });

            // Add click event to create splatter
            document.addEventListener("click", (e) => {
                paintSplatters.push(new PaintSplatter(e.clientX, e.clientY));
            });

            function applyPhysics() {
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 50 && distance > 0) {
                            const force = (50 - distance) * 0.0005;
                            const fx = (dx / distance) * force;
                            const fy = (dy / distance) * force;

                            nodes[i].applyForce(-fx, -fy);
                            nodes[j].applyForce(fx, fy);
                        }
                    }
                }

                for (let i = 0; i < nodes.length; i++) {
                    if (nodes[i].type === "mega" || nodes[i].type === "hub")
                        continue;

                    for (let j = 0; j < nodes.length; j++) {
                        if (
                            nodes[j].type === "mega" ||
                            nodes[j].type === "hub"
                        ) {
                            const dx = nodes[j].x - nodes[i].x;
                            const dy = nodes[j].y - nodes[i].y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < 300 && distance > 50) {
                                const force =
                                    0.0002 * (nodes[j].type === "mega" ? 2 : 1);
                                nodes[i].applyForce(
                                    (dx / distance) * force,
                                    (dy / distance) * force,
                                );
                            }
                        }
                    }
                }

                if (mouse.x !== null) {
                    for (let i = 0; i < nodes.length; i++) {
                        const dx = mouse.x - nodes[i].x;
                        const dy = mouse.y - nodes[i].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < mouse.radius && distance > 0) {
                            const force =
                                ((mouse.radius - distance) / mouse.radius) *
                                mouse.strength;
                            nodes[i].applyForce(
                                (dx / distance) * force,
                                (dy / distance) * force,
                            );
                        }
                    }
                }
            }

            function drawConnections() {
                particleSpawnTimer++;

                for (let i = 0; i < nodes.length; i++) {
                    nodes[i].connections = [];
                    let connectionCount = 0;
                    const maxConnections =
                        nodes[i].type === "mega"
                            ? 12
                            : nodes[i].type === "hub"
                              ? 8
                              : 5;

                    for (let j = i + 1; j < nodes.length; j++) {
                        if (connectionCount >= maxConnections) break;

                        const dx = nodes[i].x - nodes[j].x;
                        const dy = nodes[i].y - nodes[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        const connectionDistance =
                            nodes[i].type === "mega" || nodes[j].type === "mega"
                                ? 250
                                : nodes[i].type === "hub" ||
                                    nodes[j].type === "hub"
                                  ? 200
                                  : 150;

                        if (distance < connectionDistance) {
                            connectionCount++;
                            nodes[i].connections.push(nodes[j]);

                            const opacity =
                                0.25 * (1 - distance / connectionDistance);
                            const lineWidth =
                                nodes[i].type === "mega" ||
                                nodes[j].type === "mega"
                                    ? 2
                                    : nodes[i].type === "hub" ||
                                        nodes[j].type === "hub"
                                      ? 1.5
                                      : 1;

                            // GREY gradients for connections
                            const gradient = ctx.createLinearGradient(
                                nodes[i].x,
                                nodes[i].y,
                                nodes[j].x,
                                nodes[j].y,
                            );

                            if (
                                nodes[i].type === "mega" ||
                                nodes[j].type === "mega"
                            ) {
                                gradient.addColorStop(
                                    0,
                                    `rgba(130, 130, 130, ${opacity})`,
                                );
                                gradient.addColorStop(
                                    1,
                                    `rgba(110, 110, 110, ${opacity})`,
                                );
                            } else if (
                                nodes[i].type === "hub" ||
                                nodes[j].type === "hub"
                            ) {
                                gradient.addColorStop(
                                    0,
                                    `rgba(110, 110, 110, ${opacity})`,
                                );
                                gradient.addColorStop(
                                    1,
                                    `rgba(110, 110, 110, ${opacity * 0.5})`,
                                );
                            } else {
                                gradient.addColorStop(
                                    0,
                                    `rgba(100, 100, 100, ${opacity})`,
                                );
                                gradient.addColorStop(
                                    1,
                                    `rgba(100, 100, 100, ${opacity * 0.5})`,
                                );
                            }

                            ctx.beginPath();
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = lineWidth;
                            ctx.moveTo(nodes[i].x, nodes[i].y);
                            ctx.lineTo(nodes[j].x, nodes[j].y);
                            ctx.stroke();

                            // GREY data particles
                            if (
                                particleSpawnTimer % 30 === 0 &&
                                opacity > 0.15 &&
                                Math.random() < 0.3
                            ) {
                                const color = "rgba(120, 120, 120, 1)";
                                dataParticles.push(
                                    new DataParticle(nodes[i], nodes[j], color),
                                );
                            }
                        }
                    }

                    // ORANGE/YELLOW mouse connections
                    if (mouse.x !== null) {
                        const dx = nodes[i].x - mouse.x;
                        const dy = nodes[i].y - mouse.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < mouse.radius) {
                            const opacity = 0.5 * (1 - distance / mouse.radius);

                            ctx.beginPath();
                            ctx.strokeStyle = `rgba(255, 180, 60, ${opacity})`;
                            ctx.lineWidth = 2;
                            ctx.moveTo(nodes[i].x, nodes[i].y);
                            ctx.lineTo(mouse.x, mouse.y);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.arc(mouse.x, mouse.y, 10, 0, Math.PI * 2);
                            ctx.strokeStyle = `rgba(255, 180, 60, ${opacity * 0.5})`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }
            }

            function updateDataParticles() {
                for (let i = dataParticles.length - 1; i >= 0; i--) {
                    if (!dataParticles[i].update()) {
                        dataParticles.splice(i, 1);
                    } else {
                        dataParticles[i].draw();
                    }
                }
            }

            function animate() {
                // Clear and draw network graph on main canvas
                ctx.fillStyle = "rgba(240, 238, 230, 0.1)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                applyPhysics();
                drawConnections();
                updateDataParticles();

                nodes.forEach((node) => {
                    node.update();
                    node.draw();
                });

                // Clear and draw splatters on splatter canvas
                splatterCtx.clearRect(
                    0,
                    0,
                    splatterCanvas.width,
                    splatterCanvas.height,
                );

                for (let i = paintSplatters.length - 1; i >= 0; i--) {
                    if (!paintSplatters[i].update()) {
                        paintSplatters.splice(i, 1);
                    } else {
                        paintSplatters[i].draw();
                    }
                }

                requestAnimationFrame(animate);
            }

            animate();
        </script>
    </body>
</html>
